//go:build ignore

package main

import (
	"bufio"
	"fmt"
	"io"
	"net/http"
	"os"
	"strconv"
	"strings"
)

const (
	emojiTestURL = "https://unicode.org/Public/emoji/latest/emoji-test.txt"
	outputFile   = "emojis.go"
)

type Emoji struct {
	CodePoints string
	Status     string
	Name       string
	Emoji      string
}

func main() {
	fmt.Println("Downloading emoji test data...")
	resp, err := http.Get(emojiTestURL)
	if err != nil {
		panic(fmt.Sprintf("Failed to download emoji data: %v", err))
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		panic(fmt.Sprintf("Failed to download emoji data: HTTP %d", resp.StatusCode))
	}

	fmt.Println("Parsing emoji data...")
	emojis, err := parseEmojiData(resp.Body)
	if err != nil {
		panic(fmt.Sprintf("Failed to parse emoji data: %v", err))
	}

	fmt.Printf("Found %d valid emojis\n", len(emojis))

	fmt.Println("Generating Go code...")
	err = generateGoCode(emojis)
	if err != nil {
		panic(fmt.Sprintf("Failed to generate Go code: %v", err))
	}

	fmt.Printf("Generated %s with %d emojis\n", outputFile, len(emojis))
}

func parseEmojiData(r io.Reader) (map[string]bool, error) {
	emojis := make(map[string]bool)
	scanner := bufio.NewScanner(r)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Skip empty lines and comments
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Parse emoji line format: code points; status # emoji name
		parts := strings.Split(line, ";")
		if len(parts) < 2 {
			continue
		}

		codePointsPart := strings.TrimSpace(parts[0])
		statusAndName := strings.TrimSpace(parts[1])

		// Extract status (before the #)
		statusParts := strings.Split(statusAndName, "#")
		if len(statusParts) < 2 {
			continue
		}

		status := strings.TrimSpace(statusParts[0])

		// Only include component and fully-qualified emojis
		if status != "component" && status != "fully-qualified" {
			continue
		}

		// Convert code points to emoji string
		emojiStr, err := codePointsToEmoji(codePointsPart)
		if err != nil {
			continue // Skip invalid code points
		}

		emojis[emojiStr] = true
	}

	return emojis, scanner.Err()
}

func codePointsToEmoji(codePointsStr string) (string, error) {
	codePoints := strings.Fields(codePointsStr)
	runes := make([]rune, len(codePoints))

	for i, cp := range codePoints {
		// Parse hex code point
		codePoint, err := strconv.ParseInt(cp, 16, 32)
		if err != nil {
			return "", err
		}
		runes[i] = rune(codePoint)
	}

	return string(runes), nil
}

func generateGoCode(emojis map[string]bool) error {
	file, err := os.Create(outputFile)
	if err != nil {
		return err
	}
	defer file.Close()

	// Write package header
	fmt.Fprintln(file, "// Code generated by generate.go; DO NOT EDIT.")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "package emoji")
	fmt.Fprintln(file, "")

	// Write emoji map
	fmt.Fprintln(file, "// validEmojis contains all component and fully-qualified emojis from Unicode")
	fmt.Fprintln(file, "var validEmojis = map[string]bool{")

	for emoji := range emojis {
		// Escape the emoji string for Go code
		escaped := fmt.Sprintf("%q", emoji)
		fmt.Fprintf(file, "\t%s: true,\n", escaped)
	}

	fmt.Fprintln(file, "}")
	fmt.Fprintln(file, "")

	// Write IsValid function
	fmt.Fprintln(file, "// IsValid returns true if the given string is a valid Unicode emoji")
	fmt.Fprintln(file, "// with status 'component' or 'fully-qualified'.")
	fmt.Fprintln(file, "func IsValid(emoji string) bool {")
	fmt.Fprintln(file, "\treturn validEmojis[emoji]")
	fmt.Fprintln(file, "}")

	return nil
}
